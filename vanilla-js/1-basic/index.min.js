const canvas=document.querySelector("#c"),gl=canvas.getContext("webgl");if(!gl)throw alert("WebGL not supported"),new Error("WebGL not supported");function resize(e){const r=e.clientWidth,t=e.clientHeight;e.width==r&&e.height==t||(e.width=r,e.height=t)}const vertexShaderSource="\n\n// 從 buffer 中獲取數據\nattribute vec4 a_position;\n// vec4 是一個有四個浮點資料的資料型態。在 JavaScrip 中你可以把它想像成 a_position = {x: 0, y: 0, z: 0, w: 0}。我們設定的 size = 2， 屬性預設值是0, 0, 0, 1，然後屬性將會從緩衝中取得前兩個值（ x 和 y ）。 z 和 w 還是預設值 0 和 1 。\n\n// 所有著色器都有一個 main 方法\nvoid main() {\n  gl_Position = a_position;\n}\n",fragmentShaderSource="\n\n  // 片段著色器沒有預設精度，所以需要設置一個精度\n  // medium Precision 代表中等精度\n  precision mediump float;\n\n  void main() {\n    // gl_FragColor 是片段着色器主要設置的變量\n    // 上方我們設置 gl_FragColor 為 1, 0, 0.5, 1 ，其中 1 代表紅色值，0 代表綠色值， 0.5 代表藍色值，最後一個 1 表示阿爾法通道值。 WebGL 中的顏色值範圍從 0 到 1 。\n    gl_FragColor = vec4(1,0,0.5,1); \n  }\n";function createShader(e,r,t){const a=e.createShader(r);e.shaderSource(a,t),e.compileShader(a);if(e.getShaderParameter(a,e.COMPILE_STATUS))return a;console.log(e.getShaderInfoLog(a)),e.deleteShader(a)}function createProgram(e,r,t){const a=e.createProgram();e.attachShader(a,r),e.attachShader(a,t),e.linkProgram(a);if(e.getProgramParameter(a,e.LINK_STATUS))return a;console.log(e.getProgramInfoLog(a)),e.deleteProgram(a)}function main(){const e=createShader(gl,gl.VERTEX_SHADER,vertexShaderSource),r=createShader(gl,gl.FRAGMENT_SHADER,fragmentShaderSource),t=createProgram(gl,e,r),a=gl.getAttribLocation(t,"a_position"),n=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,n);gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([0,0,0,.75,.7,0]),gl.STATIC_DRAW),resize(gl.canvas),gl.viewport(0,0,gl.canvas.width,gl.canvas.height),gl.clearColor(0,0,0,0),gl.clear(gl.COLOR_BUFFER_BIT),gl.useProgram(t),gl.enableVertexAttribArray(a),gl.bindBuffer(gl.ARRAY_BUFFER,n);const o=gl.FLOAT;gl.vertexAttribPointer(a,2,o,!1,0,0);var g=gl.TRIANGLES;gl.drawArrays(g,0,3)}document.addEventListener("DOMContentLoaded",main);