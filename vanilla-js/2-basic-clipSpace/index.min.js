const canvas=document.querySelector("#c"),gl=canvas.getContext("webgl");if(!gl)throw alert("WebGL not supported"),new Error("WebGL not supported");function resize(e){const r=e.clientWidth,t=e.clientHeight;e.width==r&&e.height==t||(e.width=r,e.height=t)}const vertexShaderSource="\n\nattribute vec2 a_position;\n\nuniform vec2 u_resolution;\n\nvoid main () {\n  // 從像素座標轉換 0.0 到 1.0\n  vec2 zeroToOne = a_position.xy / u_resolution;\n\n  // 再把 0 -> 1 轉換到 0 -> 2\n  vec2 zeroToTwo = zeroToOne * 2.0;\n\n  // 把 0 -> 2 轉換到 -1 -> 1 (剪裁空間)\n  vec2 clipSpace = zeroToTwo - 1.0;\n\n  gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n}\n",fragmentShaderSource="\n\n  precision mediump float;\n\n  void main() {\n    gl_FragColor = vec4(1,0,0.5,1); \n  }\n";function createShader(e,r,t){const n=e.createShader(r);e.shaderSource(n,t),e.compileShader(n);if(e.getShaderParameter(n,e.COMPILE_STATUS))return n;e.deleteShader(n)}function createProgram(e,r,t){const n=e.createProgram();e.attachShader(n,r),e.attachShader(n,t),e.linkProgram(n);if(e.getProgramParameter(n,e.LINK_STATUS))return n;console.log(e.getProgramInfoLog(n)),e.deleteProgram(n)}function main(){const e=createShader(gl,gl.VERTEX_SHADER,vertexShaderSource),r=createShader(gl,gl.FRAGMENT_SHADER,fragmentShaderSource),t=createProgram(gl,e,r),n=gl.getAttribLocation(t,"a_position"),o=gl.getUniformLocation(t,"u_resolution"),a=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,a);gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([10,20,80,20,10,30,10,30,80,20,80,30]),gl.STATIC_DRAW),resize(gl.canvas),gl.viewport(0,0,gl.canvas.width,gl.canvas.height),gl.clearColor(0,0,0,0),gl.clear(gl.COLOR_BUFFER_BIT),gl.useProgram(t),gl.enableVertexAttribArray(n),gl.bindBuffer(gl.ARRAY_BUFFER,a);const g=gl.FLOAT;gl.vertexAttribPointer(n,2,g,!1,0,0),gl.uniform2f(o,gl.canvas.width,gl.canvas.height);var i=gl.TRIANGLES;gl.drawArrays(i,0,6)}document.addEventListener("DOMContentLoaded",main);